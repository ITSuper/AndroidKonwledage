#### Kotlin basic

1、注解相关@JvmOverloads的含义？
- @JvmOverloads:
    Kotlin中的函数可以有默认参数所以不需要重载方法，加上JvmOverloads主要是为了兼容Java代码。
-   

2、关键字inline、noinline、crossInline的含义？

Kotlin相关

# 一、协程

## 1.协程是什么？
- 定义：协程是一种轻量级的线程，它依赖于线程，协程挂起时不会阻塞线程，基于线程池的API，是一种并发设计模式。
  协程使用挂起和恢复的方式避免阻塞线程，而且可以用阻塞的方式写出非阻塞代码。
  l
## 2.简单使用：
```kotlin
   coroutineScope.lunch(Dispatcher.IO){
      val res = suspend getImageFormNet(url)
      withContext(Dispatcher.Main){
          image.setImage(res)
      }  
   } 
```

## 3.原理解析
- lunch
```kotlin
   public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
    ): Job {
        val newContext = newCoroutineContext(context)
        val coroutine = if (start.isLazy)
            LazyStandaloneCoroutine(newContext, block) else
            StandaloneCoroutine(newContext, active = true)
        coroutine.start(start, coroutine, block)
        return coroutine
}
```
(1)首先创建了协程上下文coroutineContext，它是协程运行的环境
(2)通过上下文和block创建coroutine对象
(3)调用coroutine.start()

- start
```kotlin
       public operator fun <T> invoke(block: suspend () -> T, completion: Continuation<T>): Unit =
        when (this) {
            DEFAULT -> block.startCoroutineCancellable(completion)
            ATOMIC -> block.startCoroutine(completion)
            UNDISPATCHED -> block.startCoroutineUndispatched(completion)
            LAZY -> Unit // will start lazily
        }
```
(1)start方法是调用了CoroutineStart中的invoke方法，判断协程启动模式
(2)通过block.StartCoroutine()启动协程

- block.startCoroutine()
```kotlin
    public fun <T> (suspend () -> T).startCoroutine(
    completion: Continuation<T>
    ) {
        createCoroutineUnintercepted(completion).intercepted().resume(Unit)
    }
```
- createCoroutineUnintercepted()
  创建协程的实际方法，内部将协程闭包封装成Continuation对象通过栈帧的方式存储起来，
  当协程执行完毕后通过resume方法取出再切换到原来的线程中执行


# 二、inline、noinline、crossline

- inline:修饰方法，使得方法成为内联函数，在调用时是直接将方法体复制到调用处，减少了函数类型对象的创建
- noinline:修饰内联函数的函数类型参数，表示此函数类型参数可以当作一个对象，可以用return返回这个对象
- crossline:取消内联函数中不能间接调用函数类型参数的限制

# 三、by lazy 和 late init

- late init:延时初始化。是指在声明变量时不立即初始化值，初始化工作延后进行。只能修饰 成员变量，在使用时若没有进行初始化工作，会抛出异常。
  可使用::xxx.isInitialized对变量进行初始化检查
```kotlin
   private late init  var name:String
```

- 原理：添加late init 修饰的变量在反编译后的代码中的get\set方法中加入了判空，如果为null则抛出异常


- by lazy : 懒加载。是指在声明变量时不会立即初始化，而是等到使用的时候再调用by lazy {}中的代码进行初始化工作，且只能修饰val 不可变变量。
```kotlin
   private val viewModel:HomeViewModel by lazy {
           HomeViewModel()
    }
```
- 原理：by lazy 修饰后的变量会以Lazy 变量的形式暂存，Lazy变量的默认实现是SynchronizedLazyImpl类，在此类中value值会通过synchronized()的方式进行初始化工作。

# 四、LiveData\Flow
  

# 五、ViewModel