#### Kotlin basic

1、注解相关@JvmOverloads的含义？
- @JvmOverloads:
    Kotlin中的函数可以有默认参数所以不需要重载方法，加上JvmOverloads主要是为了兼容Java代码。
-   

2、关键字inline、noinline、crossInline的含义？ let with run apply

let	1	it	lambda最后一行代码返回值
with	2	this 或者 省略	lambda最后一行代码返回值
run	1	this 或者 省略	lambda最后一行代码返回值
apply	1	this 或者 省略	返回调用者对象

# 一、协程

## 1.协程是什么？
- 定义：协程是一种轻量级的线程，它依赖于线程，协程挂起时不会阻塞线程，基于线程池的API，是一种并发设计模式。
  协程使用挂起和恢复的方式避免阻塞线程，而且可以用阻塞的方式写出非阻塞代码。
  l
## 2.简单使用：
```kotlin
   coroutineScope.lunch(Dispatcher.IO){
      val res = suspend getImageFormNet(url)
      withContext(Dispatcher.Main){
          image.setImage(res)
      }  
   } 
```

## 3.原理解析
- lunch
```kotlin
   public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -> Unit
    ): Job {
        val newContext = newCoroutineContext(context)
        val coroutine = if (start.isLazy)
            LazyStandaloneCoroutine(newContext, block) else
            StandaloneCoroutine(newContext, active = true)
        coroutine.start(start, coroutine, block)
        return coroutine
}
```
(1)首先创建了协程上下文coroutineContext，它是协程运行的环境
(2)通过上下文和block创建coroutine对象
(3)调用coroutine.start()

- start
```kotlin
       public operator fun <T> invoke(block: suspend () -> T, completion: Continuation<T>): Unit =
        when (this) {
            DEFAULT -> block.startCoroutineCancellable(completion)
            ATOMIC -> block.startCoroutine(completion)
            UNDISPATCHED -> block.startCoroutineUndispatched(completion)
            LAZY -> Unit // will start lazily
        }
```
(1)start方法是调用了CoroutineStart中的invoke方法，判断协程启动模式
(2)通过block.StartCoroutine()启动协程

- block.startCoroutine()
```kotlin
    public fun <T> (suspend () -> T).startCoroutine(
    completion: Continuation<T>
    ) {
        createCoroutineUnintercepted(completion).intercepted().resume(Unit)
    }
```
- createCoroutineUnintercepted()
  创建协程的实际方法，内部将协程闭包封装成Continuation对象通过栈帧的方式存储起来，
  当协程执行完毕后通过resume方法取出再切换到原来的线程中执行


# 二、inline、noinline、crossline

- inline:修饰方法，使得方法成为内联函数，在调用时是直接将方法体复制到调用处，减少了函数类型对象的创建
- noinline:修饰内联函数的函数类型参数，表示此函数类型参数可以当作一个对象，可以用return返回这个对象
- crossline:取消内联函数中不能间接调用函数类型参数的限制

# 三、by lazy 和 late init

- late init:延时初始化。是指在声明变量时不立即初始化值，初始化工作延后进行。只能修饰 成员变量，在使用时若没有进行初始化工作，会抛出异常。
  可使用::xxx.isInitialized对变量进行初始化检查
```kotlin
   private late init  var name:String
```

- 原理：添加late init 修饰的变量在反编译后的代码中的get\set方法中加入了判空，如果为null则抛出异常


- by lazy : 懒加载。是指在声明变量时不会立即初始化，而是等到使用的时候再调用by lazy {}中的代码进行初始化工作，且只能修饰val 不可变变量。
```kotlin
   private val viewModel:HomeViewModel by lazy {
           HomeViewModel()
    }
```
- 原理：by lazy 修饰后的变量会以Lazy 变量的形式暂存，Lazy变量的默认实现是SynchronizedLazyImpl类，
  在此类中value值会通过synchronized()的方式进行初始化工作。

# 四、LiveData？ 粘性事件？
- 定义：使用了观察者模式，是一种可观察的数据存储类，具有生命周期感知能力。
- 为什么要使用？
  （1）实时刷新数据
  （2）不会出现内存泄漏
  （3）不会因为Activity处于STOP状态而导致崩溃
  （4）不需要手动解除观察
- 原理分析： liveData本身看作一个被观察者
  （1）observe(lifecycleOwner，observer) 利用lifecycle绑定组件的生命周期，observer用于接收和处理事件
  （2）postValue 用Synchronized加锁，然后调用线程池完成线程通信
  （3）setValue  只能用于主线程，内部调用dispatchingValue回调onChange方法
- 粘性事件产生原因？
  先发生消息后注解观察者
- 解决方案：
  （1）利用hook修改mLastVersion值，让这个值与mVersion一致
  （2）用SingleLiveEvent 解决数据倒灌的问题，在onChange之前判断事件是否已经被消费了，如果已经消费了则不再往下传递
  
# 五、ViewModel
- 定义：
- 原理：  
- 如何存储？
  viewModelStore
# 六、DataBing
- 数据绑定。再xml布局用layout标签包裹，声明<data>标签，里面定义需要绑定的数据，然后就可以直接在xml值使用了。
- 原理：
  DataBinding在编译后会生成一个Binding类，在这个类持有View和Model，类中会对布局中的控件通过tag查找出来，设置一个
  监听来实时更新数据和UI。
  
# 七、Lifecycle原理
- 定义：lifecycle是一个类，用于存储有关组件（Activity\Fragment）的生命周期状态信息，并且允许其它对象观察此状态。
  （有关组件可以看成一个被观察者，通过lifecycle向其他组件发生生命周期变化的状态）
- 原理：
  （1）lifecycleOwner   生命周期拥有者（Activity等可以看成是被观察者）
  （2）lifecycleObserver  观察者（开发者自定义的处理事件的逻辑，重写生命周期方法）
  （3）lifecycle        lifecycle注入一个无页面的fragment，这个fragment的生命周期与组件关联的，组件生命周期触发后，lifecycle通过反射的方式将生命
                        周期变化发送给观察者  （lifecycle.addObserver）

