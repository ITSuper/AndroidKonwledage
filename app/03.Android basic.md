### Android basic

https://zhuanlan.zhihu.com/p/556878750
https://blog.csdn.net/hello_1995/article/details/120075342

1、Activity和Fragment生命周期？值传递方式？onNewIntent()的调用时机？
- onCreate - onStart - onResume - onRestart - onStop - onDestroy
- onAttach - onCreate - onCreateView - onActivityCreated - onResume - onRestart - onStop - 
  onDestroy - onDestroyView - onDetach
- 传值方式：
    · 通过bundle fragment.setArgument(bundle)
    · setValue
    · onAttach(context) 中通过context获取对应的Activity
    · 广播
    · eventBus
 
2、LaunchModel的应用场景？
- standard:-------标准模式，适用于普通Activity
- singleTop:------栈顶复用，用于经常打开复用的界面
- singleTask:-----栈内复用，适用于主页首页只初始化一次
- singleInstance:-单独栈内，适用于单路管理的页面

 
3、Activity的启动流程？加载流程？
- 点击Launcher中图标，执行的是startActivity方法，这个方法会AMS，由AMS完成跨进程的启动。
- AMS接收到事件后，调用了startActivity，这个方法一致往下调用，会判断对应的应用是否创建了进程？如果没有创建，则先创建进程。
- AMS创建进程调用startProcess方法，通过Process类将创建进程的请求发送给Zygote进程。
- AMS与Zygote通过Socket连接，Zygote通过调用fork创建新的进程，并且返回了进程的pid。
- 创建进程时，会通过反射创建ActivityThread，
   
4、OkHttp工作流程和原理？为啥要选用OKHttp?
- 流程原理：
    （1）构建：使用builder模式创建OkHttpClient，使用client可以配置dns、proxy、connectTimeOut等。
    （2）请求：调用client.newCall(request)方法进行请求，具体由RealCall.newCall()执行，在RealCall中提供了
            execute()\enqueue()方法。
    （3）调度：execute为同步方法，enqueue为异步方法，两种方法均由client.dispatcher执行。dispatcher为调度器，
            内部封装线程池，使用双端队列ArrayDeque存储同步或异步请求。dispatcher主要负责管理call，交由线程池
            开启、结束call请求，最终call请求还是在RealCall中实现的。
    （4）执行：RealCall中实现了NamedRunnable中的execute(在Runnable的run方法中执行)，在此方法中通过getResponseWithInterceptorChain调用了
            五层责任链，RetryAndFollowUp、Bridge、Cache、Connect、CallServer，责任链会一层一层往上返回结果，责任链调用后返回chain对象，然后
            调用chain.process(originalChain)进行请求，返回response对象。
- 选用原因：
    （1）可扩展性高，client中可以配置dns、proxy、timeOut、缓存等
    （2）通信效率高，使用了连接池缓存
    （3）层次机构清晰，方便排查问题
    （4）拦截器可自定义可自扩展

5、内存泄漏产生的原因和具体的场景？内存泄漏LeakCanary检测工具的使用？以及其工作原理？
- 原因：一个对象已经不需要使用了，但是另一个正在使用的对象持有该对象的引用导致GC无法正常回收，造成了内存泄漏。
- 场景：
    （1）单例模式下：一些单例类持有context引用
    （2）内部类使用不当：内部类会持有外部类的引用，如果内部类被持久引用会导致外部类无法被回收（成员内部类、匿名内部类）。
        **静态内部类不会持有外部类的引用**
    （3）handler导致
    （4）资源未关闭导致
    （5）EventBus等未取消注册导致
- 使用：
    （1）在build.gradle中添加LeakCanary的相关引用，或者在Application中手动添加LeakCanary.install(this);
    （2）在Application中添加refWatcher  = LeakCanary.install(this)可监听指定对象；
    （3）在运行后生成一个Leaks的应用，发生内存泄漏时这个应用会弹出提示LeakCanary is dumping memory to investigate leaks；
    （4）经过分析后在Leaks中会有对应的内存泄漏的引用链；
    （5）在引用链中查看Leaking NO ->  Leaking YES 找到对应的发生内存泄漏的地方；
- 原理：[LeakCanary 内存泄漏原理完全解析](https://juejin.cn/post/6844903730190483470)
    · 安装启动：
        LeakCanary 1.0之前需要在application中手动调用install，但是2.0之后就不需要了。因为LeakCanary中的AppWatcherInstaller继承自
        ContentProvider，启动应用时会调用application，application下所有的ContentProvider都会自动启动，所以不用init初始化了。
    · AppWatcherInstaller：
        在onCreate方法中执行AppWatcher.manualInstall(application)方法
    · AppWatcher：
        在manualInstall方法中，检查是否是在主线程->是否已经安装->LogcatSharkLog安装->设置LeakCanaryListener->
        遍历安装四种Watcher(Activity,FragmentAndViewModel,RootView,Service)
    · ObjectWatcher：
        以上的四种Watcher的功能都是通过ObjectWatcher实现的。内部维护了一个ReferenceQueue队列，当弱引用对象被回收时
        会被放入此队列中，可通过queue.poll()方法获取改弱引用对象。
    · InternalAppWatcher：
  
5、ANR日志分析？
  
6、SharedPreferences的工作原理?读写存在的问题?造成ANR的原因？如何优化？进程同步？
- 原理:
    （1）加载文件：SharedPreferences是一个接口，其实现类是SharedPreferencesImpl。在此类中会开启子线程，调用loadFromDisk加载xml
            文件，将xml文件数据读取到HashMap集合中保存。
    （2）读数据：在SharedPreferencesImpl中，getXXX方法为获取数据方法，内部通过synchronized(lock)进行加锁操作，在synchronized中需要获取到加载文件成功的锁mLoaded，
            保证在加载文件成功后才能获取数据。（这个等待锁的机制可能会造成ANR）
    （3）写数据：写数据由EditorImpl类实现，此类为成员内部类，继承自Editor。所有putXXX方法通过synchronized加锁，将修改的数据放入
            HashMap中。并提供commit()和apply()两种方法进行同步内存数据和写入磁盘操作。
    （4）内存同步：就是将EditorImpl类中的HashMap数据同步至外部类SharedPreferences类的HashMap集合中，主要的方法时commitToMemory()。
    （5）磁盘同步：就是将SharedPreferences中HashMap的数据同步至xml文件中。
- 读文件:
    因为SharedPreferences第一次初始化时会开启子线程加载文件，并且在读取数据时使用了synchronized，如果文件加载时间过长，
    UI线程获取不到锁，可能会导致ANR的情况。
- 写文件:
    (1)commit: 会将数据同步写入内存中,内存数据更新,再同步写入磁盘中.如果在UI线程中使用,当文件较大时,会出现ANR的问题，不建议在UI线程中使用
    (2)apply : 会将数据同步写入内存中,内存数据更新,再异步写入磁盘中.建议使用在UI线程中使用,但是任然可能出现ANR.
- 原因：
  （1）初次加载和获取数据时，因为getXXX方法中使用到了等待锁的机制，如果文件加载时间长则可能造成ANR
  （2）使用commit
  （3）使用apply
- 优化：
  （1）使用SP时尽量存储简单和少量数据，多次数据修改可进行一次提交同步
  （2）使用SP时，在工作线程中建议使用commit，此方法开销更小。在主线程时，要使用apply进行异步提交。
  （3）使用MMKV替换
  （4）使用DateStore替换
- 进程同步：
    

7、Jetpack相关的ViewModel、DataBinding、LiveData、Flow、Lifecycle？
- ViewModel

8、ActivityThread类

9、IPC通信机制

10、文件编译、转换阶段和过程、插件的编译原理

11、注解处理器的工作原理？

12、IntentFilter匹配规则，action和category区别？                  

13、ContentProvider原理

14、TouchEvent传递过程？ onTouchEvent返回false怎么办?

15、磁盘内存映射原理

16、handler机制相关 looper  阻塞线程？

17、activity 启动过程  activity创建过程   activity启动到加载view的过程

18、view绘制过程

19、RecyclerView相关

20、ANR相关  OOM相关

21、图片加载、压缩、缓存

22、MCV\MVP\MVVM

23、为什么不能在子线程刷新UI?


