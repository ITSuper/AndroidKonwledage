#### JAVA基础问题
https://zhuanlan.zhihu.com/p/556878750

###一、基础部分

1、泛型是什么？谈谈你对泛型的理解？泛型存在的阶段是在运行阶段还是编译阶段？什么是泛型擦除？为啥需要泛型擦除？泛型擦除带来的问题？
retrofit是如何获取泛型擦除后的泛型类型的？
- 泛型是指的在定义类、接口、方法时不局限的指定某一种特定的类型，而是让类、接口、方法的调用者来决定
  具体使用那种类型的参数。通常使用T、E、K、V等大写字母来标识泛型参数。
- 泛型擦除：泛型只存在于编译阶段，在运行时会去掉类型信息。
- 泛型通配符：
  1、无界通配符<?>:让泛型能够接受未知类型的参数；
  2、上界通配符<? extents T>:表示类型的上界，表示参数化类型可能是T或者T的子类；
  3、下界通配符<? super T>:表示类型的下界，表示参数化类型可能是T或者T的父类，直至Object；
- 为什么要由泛型擦除？
  避免在运行时创建过多的类而导致内存和性能相关的问题
- 泛型擦除带来的问题？
- 如何获取泛型擦除后的类型？
  可以利用反射。但是泛型不是在运行后就被擦除了么？声明侧泛型会被记录在class文件中

2、Java中Static的理解？有什么特点？
- static关键字能够修饰成员变量、成员方法、代码块、内部类
  （1）修饰成员变量和方法：
  被static修饰的成员变量和方法属于这个类，不单单属于这个类的某个实例对象，被所有的实例对象共享。
  被static修饰的成员变量是静态变量，存放在JVM内存模型中的方法区中。
  （2）修饰代码块：
  被static修饰的代码块称为静态代码块，静态代码块的执行在非静态代码块之前（静态代码块》非静态代码块》构造方法）
  静态代码块在类的加载和创建中只被调用一次。
  （3）修饰内部类：
  被static修饰的内部类称为静态内部类。
  1、可以通过外部类类名直接调用，不用创建外部类的实例对象
  2、静态内部类只能访问外部类的静态成员                                                                                                           
- 特点：
  1、随着类的加载而加载
  2、优先对象而存在
  3、被类的所有实例对象所共享
  4、可以通过类名直接调用

3、Java中final的理解？有什么特点？
- final可以修饰类、成员方法、成员变量
  ·修饰类： 该类不可以被继承
  ·修饰方法： 该方法不可以被重写
  ·修饰变量： 该变量不能够被重新赋值，属于一个常量
- 与finally、finalize有什么不同？
  · finally是保证重点代码一定被执行的一种机制。try-catch-finally在异常捕获中，或者用于 unlock解锁操作
  · finalize是保证对象在垃圾回收之前完成特定的资源回收

4、Java中变量存储的位置？final修饰和static修饰的变量?
- 局部变量：
  声明在方法中，会随着方法的结束而销毁。基本数据类型和引用类型都是存储在JVM虚拟机栈中的。
- 成员变量：
  声明在类的成员位置的变量，是成员变量也可称为全局变量，其声明周期跟随类。
  基本数据类型和引用类型都存储在堆中。
- static修饰的变量：
  使用static修饰的变量。static变量属于类，不属于对象，存储在方法区中。
- final 修饰的变量：
  使用final修饰的变量其实是一个常量，存储在方法区中的常量池中。

5、String常量池？String、StringBuffer、StringBuilder的区别？为什么String要设计成不可变？String不可变的好处？
- 字符串常量池：为了避免系统中存储大量的字符串，所以加入字符串常量池。
  其机制是当创建一个字符串时，首先会检测常量池中是否有相同的字符串，如果有则直接使用，如果没有则新建字符串对象，返回其引用对象，
  并将字符串对象放入常量池。当使用new String()的方式创建字符串时，会把字符串放入堆或者栈中，不会放入常量池。
- 区别：
  · String类是由final修饰的，是不可变字符串，拼接、裁剪等操作都会产生新的字符串对象。
  · StringBuffer、StringBuilder底层都是以一个有序的字符序列（char数组）进行存储。他们对象的值是可以改变的，但是值改变其对象的
  引用不会改变。
  · StringBuffer中，用Synchronized对内部的方法进行了加锁操作，能够在并发场景中使用，是线程安全的。
- 不可以变的好处：
  · 线程安全，可以在并发场景中直接使用
  · 可以作为key来进行hash计算
  · 因为其不可变的特性，所以才有了字符串常量池，可以节省大量内存空间
       
6、枚举？注解?什么是元数据？
- 元数据：可以加在类、方法、成员变量上的额外信息，对数据进行描述的数据。
  可以进行编写文档、代码分析、编译检查
  
- 枚举：一个【类的对象的实例】有限且固定的，比如季节、星期、月数等。
    是一种特殊的数据类型，可以看成是一个类类型的数据，它有较强的约束。
- 注解：是Java中的一中元数据，可以添加在类、方法或者变量上。
- 注解分类：
    按属性：· 标准注解：@overwrite 之类的java自带
           · 元注解：@Retention @Target @Inherited @Documented @Repeatable用于自定义注解
           · 自定义注解：利用元注解定义的
    按运行阶段：
            · 编译时注解
            · 运行时注解
- 注解保留：@Retention 的属性value是一个RetentionPolicy枚举值
    · source  注解只会保留在源文件，编译时会被遗弃
    · class   注解会保留在编译后的class文件中，当class加载后会遗弃注解
    · runtime 注解不仅保留在class文件中，还会保留到虚拟机运行时一直存在
  分别对应  源文件  .class文件   内存中的字节码
- 注解处理器：
    
   
7、== 、 equals 、hashcode 区别？Java 中深拷贝与浅拷贝的区别？实现方式？
- 区别：
  · == 是对内存地址的比较，内存地址是否指向同一个对象
  · equals 是对字符串内容进行比较 
  · hashcode 获取对象的哈希码
- 区别：
  · 浅拷贝：在拷贝对象时，对基本数据类型的值进行复制，对引用类型只进行引用的传递，没有创建一个新的对象。
  · 深拷贝：在拷贝对象时，对基本数据类型的值进行复制，对引用类型会创建一个新的对象。
- 实现方式：
  · 浅拷贝：clone方法
  · 深拷贝：
  （1）先序列化对象，再反序列化得到一个新的对象
  （2）使用clone方法后，再对该对象的引用类型实现一次clone
  
8、Error和Exception的区别？强弱软虚引用区别？
- 区别：
    相同点：error和exception都是java中throwable的子类可以通过java异常捕获机制进行捕捉。
    不同点：exception主要是指的在运行中能够预见的一些异常情况，这些异常情况一般不会影响程序的正常运行。
            error主要是指的运行时出现的一些意料之外的错误，这些错误很可能会阻断程序的正常运行。
    exception:可检查 和 不可检查异常，不可检查异常一般时runtimeException
    常见的exception和error：
        checkedException: IOException、classNotFundException
        unCheckedException:NullPointerException、indexOutOfBoundsException
        error:StackOverflowError、OutOfMemoryError
- 区别：
    强引用：普通对象都默认强引用，只要有一个引用指向这个对象，这个对象就不会被垃圾回收
    弱引用：week 比强引用稍弱，当JVM内存不足时，垃圾回收机制才会试图去回收这个对象
    软引用：soft 垃圾收集器扫描到软引用时会直接进行回收
    虚引用： 虚引用对象随时都可能被垃圾收集器回收。但是它不能单独使用，必须配合引用队列，虚引用的目的
            主要是跟踪垃圾回收的过程。


###二、面向对象

1、面向对象的特征分别是什么？如何理解？有什么利弊？多态实现的条件？
- 分别是
  · 封装：隐藏了实现的细节，仅提供外部访问的方式
      - 利弊：提高代码的复用性、安全性，可以隐藏实现的细节
  · 继承：多个类中存在相同的功能和操作时，把这些相同的功能和操作抽取到同一个类中，那么这些类就可以不再定义这些
         功能和操作，只需要通过extends关键字继承那个类即可。
      - 利弊：提高了代码的复用性、维护性，是多态的前提。但是提高了类与类之间的耦合关系。
  · 多态：引用变量所指的具体类型和改变了所调用的具体方法，在编程时不确定，而是在程序运行期间才确定的。
- 多态实现的条件：
  · 继承、重写、向上转型（子类的引用赋给父类对象Father father = new Son()）
  
2、接口和抽象类的区别？
- 相同点：
  （1）都可以定义方法和属性
  （2）都可以看作是一种特殊的类，其子类或者实现类都必须实现其中的抽象方法。
  （3）都不能被实例化
  （4）都可以实现多态
- 不同点：
  （1）继承：接口可以多实现，但是接口只能继承接口。抽象类只能单继承，但是抽象类可以继承普通类也可以继承抽象类。
  （2）方法：接口中的方法默认是public abstract , 抽象类中的方法可以是抽象的也可以是具体的。
  （3）变量：接口中的变量默认是public static final , 抽象类中的变量可以是任意修饰符。
  （4）构造器：接口不能有构造器，抽象类可以有。
  （5）设计理念：
        接口：  **对行为的抽象** 一般用于延申类的行为方式。是一种**自上而下**的设计，先规定行为方法，然后有实现类去实现行为方法。
             接口与实现类是一种 LIKE-A 关系，接口与实现类的关系只是定义了行为。
        抽象类：**对类的抽象**   一般用于一系列子类的模板设计，定义一些公有的功能和操作。是一种**自下而上**的设计，先有子类，然后抽取公有的功能和操作，构成抽象类。
             抽象类与实现类是一种 IS-A 关系，存在父子关系，是一种重耦合。 
             
3、Java内部类的使用和理解？
- 内部类的概述、特点、分类：
  概述：把一个类定义在另一个类的内部，这个类被称为内部类。
  特点：内部类能够直接访问外部类的成员，包括私有成员。
  作用：实现功能隐藏、减小内存开销、提高程序的运行速度。
  分类：
  （1）成员内部类：  定义在类的成员位置的内部类
   - 访问必须创建外部类实例对象
   - 成员内部类可以访问外部类的所有成员  
   - 成员内部类不能声明静态成员
  （2）局部内部类：  定义在某个函数或者某个作用域中的内部类。
   -  **局部内部类访问局部变量必须用final修饰？**
      因为局部变量会随着方法调用结束而被摧毁，而局部内部类不会随方法调用结束而摧毁，此时要想正确访问到局部变量，必须使用final进行修饰，final修饰后的
      局部变量存储在方法区中属于一个常量，生命周期不会随方法结束，所有可以在局部内部类中正常访问。
  （3）静态内部类：  使用static修饰的成员内部类
   - 访问静态内部类可以直接通过外部类类名访问，不需要创建外部类的实例对象
   - 静态内部类访问外部类数据必须是静态的
   - 静态内部类内部成员可以是静态的也可是非静态的
  （4）匿名内部类：  是局部内部类的简化写法，前提需要一个类或者接口（也可以是抽象类）
   - 格式：
   ```
      new 父类构造器(参数列表) 或 实现接口(){
         重写的方法
      }；
   ```   
  - 本质：**是继承了该类或者实现了该接口的子类的匿名对象**

4、Java的绑定机制的理解？
- 定义：把一个方法与其所在类或者对象关联起来叫方法的绑定，方法绑定分为 静态绑定 和 动态绑定 。
  · 静态绑定：
     在程序运行前就知道这个方法属于那个类了，可以直接定位到类中的具体方法。被final、static、private修饰的方法和属性。
  · 动态绑定：
     在程序运行时才能知道方法属于那个类。
     动态绑定是多态性得以实现的重要因素，它通过方法表来实现：每个类被加载到虚拟机时，在方法区保存元数据，其中，
     包括一个叫做 方法表（method table）的东西，表中记录了这个类定义的方法的指针，每个表项指向一个具体的方法代码。
     如果这个类重写了父类中的某个方法，则对应表项指向新的代码实现处。从父类继承来的方法位于子类定义的方法的前面。

### 三、数据结构

1、谈谈你对Java集合的理解？
- Java容器可分为两大类：
  Collection: 
            - List :
                      · ArrayList
                      · LinkedList 
                      · Vector
            - Set :
                      · HashSet
                        - LinkedHashSet
                      · TreeSet
  Map      :
           - HashMap 
  
           - LinkedHashMap
            
           - ConCurrentHashMap

           - TreeMap

  (1)ArrayList:底层由动态数组构成，内部有动态扩容机制，当容器容量不足时，会自动扩容。支持随机访问，写的效率低，
  读的效率高。
  (2)LinkedList:内部由静态内部类Node构成双向链表结构，Node中有next、prev节点，将链表中的每个节点都通过next\prev连接，
  能够保证有序性，添加和移除的效率高，但是查找的效率较低。
  (3)Set集合：主要有HashSet、LinkedHashSet、TreeSet，这些集合的底层基本都是有map来实现的，hashSet基于HashMap，LinkedHashSet基于LinkedHasMap，
  TreeSet基于TreeMap。Set集合利用了map中Key的唯一性来保证Set集合的唯一。例如HashSet，底层由HashMap实现，put的数据作为Key，内部new object作为value，
  然后存放在HashMap中。
  在HashSet的多个重载的构造函数中，有一个是三个参数的构造函数，在这个构造函数中map的初始化是使用的LinkedHashMap。
  (4)HashMap: 底层由数组+哈希表+链表or红黑树实现。put进入的元素，通过对Key的hashCode再进行操作，进而确定数据在数组中的位置，当不同数据的key值发生哈希碰撞时，
  数据会以链表的形式放在前一个数据的后面，当链表的长度超过8时，会将整个链表替换成红黑树的数据结构。
  (5)LinkedHashMap: 底层是由双向链表+哈希表实现，其继承至HashMap，是对HashMap的一种外层包装。由于其双向链表的结构，
  它能够保证数据的插入顺序，在其内部维护有一个
  按照元素插入顺序或者元素访问顺序的链表，如果按照插入顺序，则可以按照ArrayList一样使用，如果按照元素访问顺序，
  则可以用于实现LRUCache算法
  (6)ConCurrentHashMap: 是HashMap的线程安全版，底层和HashMap一样使用数组+链表+红黑树实现，能够在多线程中使用。在JDK 1.7中，使用的是分段锁技术，
  在JDK1.8中CAS+Synchronized来保证并发，对于节点Node使用Volatile修饰保证可见性。
  (7)TreeMap: 底层是由红黑树实现，可保证键值的有序性和唯一性。

2、在HashMap中为什么要使用链表？为什么要使用红黑树？为什么要在长度为8时进行替换？是怎样进行替换的？
  - 为什么使用链表？
    是从空间占用、查找效率、写入效率等多个方面综合考虑，从查找和写入效率来看，对比ArrayList，单链表的效率都要高，从空间占用上，对比双向链表，
    单链表只有一个指针，空间占用小，而且单链表从头到尾连接，用于遍历也能满足要求。链表不是最优的，但是较为合适的。
  - 为什么要使用红黑树？
    链表的查找时间复杂度为O(n)，红黑树的查找时间复杂度为O(log(n))，当n(链表长度)比较小的时候，这两个值相差不大，但是链表长度越大时，
    红黑树的效率就会高很多，为了提升查找效率，需要将链表转为红黑树。
  - 为什么不直接使用红黑树？
    在链表长度较小时，链表能够满足查找要求，而且相对红黑树来说占用的空间更小。
  - 为什么替换的阈值为8？
    （1）长度大于8时，链表的查询效率低于红黑树
    （2）防止因用户自己定义的哈希算法导致链表过长而影响查询效率
    （3）防止红黑树和链表之间频繁的转换
      
### 四、JAVA反射

1、谈谈你对Java反射的理解？
- 定义：反射机制是指在运行状态时，对于任何一个类都能够知道这个类所有的属性和方法，而且能够去调用它的方法和属性。这种动态获取信息
和调用方法的机制称为反射机制。
- 原理：反射的原理是类在通过ClassLoader加载后，会生成一个java.lang.Class的实例对象，然后通过java.lang.reflect包下的API去获取
  这个类的实例中的各种信息。
- 作用：   
    - 1.在运行时判断任意一个对象所属的类。
    - 2.在运行时构造任意一个类的对象。
    - 3.在运行时判断任意一个类所具有的成员变量和方法。
    - 4.在运行时调用任意一个对象的方法。
    - 5.生成动态代理。
- 为什么要使用反射？
  使用反射可以提高效率、降低代码耦合度、提高代码的适应能力。从框架上来说，一些优秀的框架retrofit，用到了注解+
  反射来实现，让用户可以简单便捷的使用。从设计模式来说，动态代理也用到了反射来创建代理类，增强了代码的适应能力。

### 五、JVM相关

1、JVM内存模型和Java内存模型？
- JVM内存模型：指的是JVM的内存分区，一般分为以下几个区域
  （1）程序计数器：记录当前程序执行的字节码，用于保障程序的分支、循环、跳转、异常等正常执行。
  （2）本地方法栈：存储与本地native交互的字节码。
  （3）虚拟机栈：  存储局部、临时变量，内部用栈帧结构（1）局部变量表（2）操作数栈（3）动态链接（4）返回地址
  （4）方法区：存储元数据、类信息、常量池等
  （5）堆：存储实例对象，是GC作用的主要区域
- JMM(Java Memory Model):JMM是指在共享内存系统中，对程序读写操作的一种规范，解决了多线程并发中出现的有序性、可见性、原子性问题。
  JMM规定系统中所有的变量都存在于主内存中，每个线程有自己的工作内存，工作内存中保留有主内存变量副本拷贝，线程只能够对自己工作内存中
  的变量进行读写操作，不能直接操作主内存，也不能操作其它线程中的变量，线程之间的变量传递通过主内存实现。
  JMM提供了volatile、synchronized、concurrent包等关键字，开发者可以使用这些关键字来进行并发擦走，不需要关心底层实现。
       
2、谈谈你对GC机制的理解？
- 定义：GC机制也称垃圾回收机制，是JAVA垃圾回收算法，释放无任何引用的对象的内存空间的一种机制。其主要作用的区域是JVM运行时数据的堆中。
- 详细：JAVA中主要采用的是“分代收集算法”。当对象被创建时，首先会被分配到年轻代的Eden区中（当然一些大对象也可能直接被分配到老年代），当Eden区快满时，会执行Minor GC，将
    Eden区中不可达的对象清除，并将所有存活的对象赋值到存活区S0中，另一个存活区S1此时是空白的。
    到下一次Eden区满时，再执行Minor GC后，将所有存活对象复制到存活区S1中，并清理S0中的不可达对象后，将S0中的存活对象复制到S1中。
    经历过几次相同的步骤后，存活区中达到阈值，将所有任然存活的对象复制到年老区中。
    年轻代采用的是“停止-复制算法”，年老代采用的是“标记-整理算法”
    年轻代在经历多次的回收算法后，将存活的对象复制到年老代中，年老代的内存空间比较大，发生GC的次数比较少。
    永久代，主要回收两种：常量池中的常量，无用的类信息。常量没有任何引用后就可以被回收，对于无用的类需要注意以下三点：
    （1）类的所有实例都已经被回收
    （2）加载类的ClassLoader都已经被回收
    （3）类对象的Class对象没有被引用（没有通过反射使用到该类）
         
3、内存泄漏？内存溢出？内存抖动？解决办法？
- 定义：
  · 内存泄漏：是指当一个对象已经不需要被使用，应该被回收时，另一个正在使用的对象持有该对象的引用，导致GC不能正常回收该对象，该对象
  不正常的保留在内存中，从而产生了内存泄漏。
    引发：
     1、单例模式中持有Context上下文的引用。
        解决：可以换成Application中Context。
     2、Handler由内部类创建会持有外部类（Activity）的引用，当Activity生命周期结束而线程未结束就会出现内存泄漏。
        解决：创建Handler的类变成静态内部类。
     3、
  · 内存溢出：当JVM运行时数据区内的空间超过了虚拟机分配的空间就会造成内存溢出，也称为OOM
  · 内存抖动：是指一个内存区域频繁的进行GC回收，从而造成频繁的内存波动。
- 内存泄漏的检测：
  · LeakCanary工具
  
### 六、类的加载

1、类的加载了解么？谈谈类的加载？类的生命周期？
- 过程：IDE中的.java文件经过编译器编译后形成.class文件，.class文件将会以二进制数据的形式被类加载器加载到运行时
    数据区的方法区中，并且形成一个java.lang.Class对象，java会对外提供访问这个Class对象的API。
- 步骤：加载 - 连接 - 初始化 ，其中连接又分为 验证 - 准备 - 解析 。  
  （1）加载：将.class文件读取成二进制的字节流，在方法区中生成.Class对象。
  （2）验证：验证文件格式、元数据、字节码等
  （3）准备：在方法区中对类变量进行初始化（static）
  （4）解析：将常量池中的符号引用替换成直接引用
  （5）初始化：对类变量进行赋值及执行静态代码块
- 生命周期： 加载、连接、初始化、使用、卸载。  
  
2、类加载器分类？什么是双亲委托？有什么好处？如何打破？
- 分类：
  （1）启动类加载器（bootstrap Classloader）
  （2）扩展类加载器（extented classloader）
  （3）应用类加载器（application classloader）
  （4）自定义加载器（user-defined classloader）
- 加载类时，挑选类加载器的一个机制。
  在加载一个类的过程中，ClassLoader首先会判断这个类的相关父类有没有被加载，如果父类没有加载则优先加载父类，如果没有父类，
  则交给上层的ClassLoader去尝试加载，上层ClassLoader在其加载范围内没有找到该类，就又继续往上层传递，直至顶层的ClassLoader。
  如果顶层的ClassLoader也没有加载，则交给自己加载。
- 好处？
  （1）防止重复加载类
  （2）安全，防止自定义同名类被加载。
- 如何打破？
  利用线程上下文加载器（thread context classloader）
  
  
3、对象的创建过程?对象如何分配内存？对象的内存模型？
- 创建过程：
  · 拿到创建指令：遇到new指令时，在方法区中的常量池中找到这个类的符号引用。
  · 检测符号引用：检查这个类是否被加载，如果没有加载类先去加载，否则直接分配内存。
  · 分配内存：在运行时数据区中的堆分配内存
  · 初始化：对对象头进行初始化，包括对象的元数据、GC代、哈希码
  · 执行构造方法
- 分配内存：有两种方式，指针碰撞 和 空闲列表 
  · 指针碰撞
  · 空闲列表
- 内存模型：
  · 对象头 ：包括元数据、GC年龄代、哈希码
  · 实例数据：类中的字段属性
  · 对齐填充：为了保证对象内存模型的长度为 8 字节的整数倍
  
4、对象创建有几种方式？
- 有四种方式：
  · 直接New
  · 通过反射
  · 通过实现Cloneable接口并重写Clone方法
  · 通过反序列化

### 七、JAVA多线程、并发编程

1、进程和线程是什么？多进程和多线程有什么意义？
- 进程：一个正在运行的程序，是系统分配资源和空间的独立单位。每个进程都有自己的内存空间和系统资源
  · 意义：提高CPU的使用率、效率
- 线程：一个进程内部可以执行多个任务，每个任务可以看出一个线程。是程序使用CPU的基本单位。
  · 意义：提高程序的使用率、效率
  
2、创建线程的几种方式？区别是什么？Thread控制？sleep和wait的区别？
- 创建方式：
  · 继承Thread类，重写run方法
  · 实现Runnable接口，实现run方法
  · 实现Callable接口，实现call方法
- 区别：
  · 继承类
  · 实现接口
  · callable接口  call() 方法可以返回值和抛出异常
- 线程状态：新建、就绪、运行、阻塞、死亡  
- 线程控制：
  · start : 开启线程
  · sleep : 指定线程休眠，不会释放对象锁
  · join  : 加入线程，让线程A执行完后再执行线程B
  · yield : 线程礼让，使当前线程重新回到可执行状态，重新抢占资源
  · stop  : 停止线程运行
  · interrupt :调用wait、sleep后线程进入阻塞，调用interrupt后抛出异常可以进行唤醒。
- 区别：
  · sleep来自Thread类，不会释放锁
  · wait来自object类，会释放锁
  
3、什么是线程安全？线程安全的核心要素？
- 定义：线程安全是指当多个线程访问同一个对象时，在不需要额外的进行同步情况下，所有的线程对对象的操作都能得到一个
    正常的结果。
- 要素：
    · 原子性：是指操作要么不执行要么就全部执行
    · 可见性：当多个线程访问一个共享变量时，一个线程修改了后，其它线程能够立马看到。
    · 有序性：程序按照代码的顺序执行
                                                                                                                                
4、谈谈你对线程池的理解？工作机制是什么？执行流程？有那些分类？拒绝策略如何实现？
- 定义：线程池是一种多线程处理方式，创建若干个可执行的线程放入一个容器中，从容器中获取线程不用自行创建，使用完毕后
    再将线程放回容器中。
- 优点：
    · 可重复利用已创建的线程，降低资源的消耗
    · 任务不用等待线程创立，可直接利用现有的线程执行，提高了响应速度
    · 提高线程的可管理性
- 工作机制:
    创建：通过ThreadPoolExecutor创建线程，返回一个ExecuteService。
    提交：提交任务有 execute()\submit()方法。execute()没有返回值，无法判断任务是否成功
        执行，submit()方法会返回一个Future对象，可以判断任务是否执行成功（通过使用future.get()返回获取返回值，但是会阻塞
        当前线程直到任务完成，而使用get(timeout,unit)方法会在一定时间返回，此时任务可能没有执行完毕）。
    关闭：shutdown()\shutdownNow()关闭线程，原理是遍历线程池，逐个调用interrupt()中断线程。shutdown()没有返回，shutdownNow()
        返回等待执行任务的列表。
    addWorker():在线程池中创建线程并执行。
- 参数含义：
    · corePoolSize ---------------- 核心线程数：
    · maximumPoolSize ------------- 最大线程数：
    · keepAliveTime --------------- 线程空闲时存活时间：
    · unit ------------------------ 时间单位：
    · workQueue ------------------- 用于保存等待执行任务的阻塞队列
    · threadFactory --------------- 线程工厂，用于创建线程、设置线程
    · rejectedExecutionHandler ---- 线程池的饱和策略
- 执行流程：
    （1）如果正在执行的线程数没有达到核心线程数，就会启动一个核心线程执行新的任务，
    （2）如果执行的线程数达到了核心线程数，则会将任务放入任务队列中等待执行
    （3）如果任务队列满了，此时还未达到最大线程数，则启动一个非核心线程去执行
    （4）如果达到了最大线程数，则拒绝执行，会调用RejectedExecutionHandler通知开发者。
- 线程池分类：
    （1）FixedThreadPool      固定线程数的线程池，最大线程数等于核心线程数   最大线程 ==     核心线程
    （2）SingleThreadPool     单个线程的线程池                           最大线程 ==     核心线程 == 1
    （3）CachedThreadPool     无界线程池，会根据需要新建线程的线程池，       最大线程 = 1    核心线程为0  核心线程= 0 
    （4）ScheduledThreadPool  核心线程数固定，非核心线程没有限制的线程池     最大线程 == 最大  核心线程固定  非核心线程 无界
- 拒绝策略：
    （1）

5、synchronized的理解?volatile的理解?ReentrantLock是什么？
- synchronized: 用于修饰方法、代码块，可以保证在同一时刻只能有一个线程能够访问该段代码。
- volatile    : 是一种轻量级的锁，一般用于修饰变量，可以保证变量的可见性和原子性。.
- ReentrantLock:是一套互斥锁，相比synchronized提供有更高级的功能
    · 等待可中断，持有锁的线程长时间不释放锁，正在等待的线程可以放弃等待，可以避免出现死锁。
    · 公平锁，正在等待的线程，按照申请时间获得锁
    · 锁多个条件
  
6、ReentrantLock和synchronized的区别？乐观锁和悲观锁？CAS操作？死锁？如何避免死锁？
- 区别：
    · 用法上ReentrantLock需要结合try/finally 来进行lock和unlock的操作
    · 等待可中断
    · 公平锁
    · 锁条件
- 乐观锁和悲观锁：是两种不同的思想，用于解决并发场景下数据竞争问题。
    · 乐观锁：认为别人不会同时修改数据，不会上锁，在操作数据时会判断，如果有人修改了直接放弃操作。
        例如：CAS操作
    · 悲观锁：认为别人会同时修改数据，操作数据时直接上锁，等操作完成后才释放锁。
        例如：synchronized、ReentrantLock
- CAS（compare and swap ）：有三个操作数
  （1）需要读写的内存位置V
  （2）进行比较的预期值A
  （3）拟写入的新值B
- 死锁：
    （1）发送资源抢夺
    （2）循环申请对方资源
    （3）循环等待对方资源
    （4）互相不释放
  
7、Atomic类的理解？

### 八、网络相关

1、http和https区别？为什么https更加安全？什么是SSL\TSL？
- 区别：https = http + ssl。
- 安全：在https中，其有证书验证和内容传输两个阶段，在证书验证阶段使用了非对称加密，在内容传输阶段使用了对称加密。
    首先Https在服务端会生成一套证书含有公钥和私钥，公钥加密的内容只能由私钥解密，私钥加密的内容只能由公钥解密。服务端将
    公钥发送给客户端，客户端收到公钥后，对证书进行验证，验证完成后生成一个随机数，利用公钥进行加密（RSA加密）。服务端接收
    后使用私钥解密得到随机数，利用这个随机数对消息内容进行AES加密后再传输给客户端，客户端也利用随机数进行解密。
- SSL/TSL: SSL是一个二进制的文件，里面包含了认证的网站公钥和元数据。

2、什么是Http报文？报文的结构？
- 定义：报文是客户端与服务端之间传递消息发送的数据块。可以分为两类：请求报文 和 响应报文
- 结构：
   - 请求报文：
        · 请求行：<method> <request - url> <version>----请求方法、请求URL、http版本
        · 请求头：<headers>-----------------------------用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力。Date、Authorization
        · 请求体：<entity - body>-----------------------请求参数tell=0123456&phone=1232123... 
   - 响应报文：
        · 状态行：<version> <status> <reason - phrase>----HTTP版本、数字状态码、原因短语。
        · 响应头: <headers>-------------------------------谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令
        · 响应体: <entity - body>-------------------------响应内容{page:"1",size:"12"...}
    
3、什么是HTTP协议？有啥特点？HTTP与Socket区别？
- 定义：HTTP协议是超文本传输协议，是一种应用层协议。它通过传输层的TCP协议可以在客户端与服务端传输数据。
- 特点：客户端每次发送的请求，都需要服务器响应，请求结束后会释放连接，从建立到释放成为一次连接。
- 区别：
    · HTTP是应用层协议基于TCP协议。使用”请求-响应“的方式建立连接，客户端发出请求，服务端接收请求后再进行响应。
    · Socket(套接字)是对TCP/IP协议的封装，是接口不是协议。Socket建立连接三个步骤：服务端监听 - 客户端请求 - 连接确认，
    服务端可以直接将数据发送到客户端。
  
4、HTTP个版本的特性？
- HTTP 1.0: 最早使用，简单的网页和网络请求。
- HTTP 1.1：在1.0之后开始运用于各大浏览器中。
  相对1.0的区别是：
    （1）1.0默认使用短连接 1.1默认使用长连接
    （2）1.1添加了很多headers内容，扩展1.0的功能
- HTTP 2.0：相对 1.x来说提升巨大，并且使用https协议
    （1）二进制格式：1.x基本文本，2.0基于二进制的帧是一个二进制协议。
    （2）多路复用：一个request对应一个id，一个连接中可以有多个request，接收方根据id再来区分不同的请求。
    （3）Headers压缩：压缩传输headers的大小
    （4）服务端推送
- HTTP 3.0：
    （1）减少TCP三次握手以及TSL握手时间
    （2）流量控制功能
    （3）优化了重传策略
    （4）避免了多路复用线头阻塞的问题

5、请求服务器的方式？GET和POST的区别？Get传递数据上限XXX？
- 请求方式：GET、POST、PUT、DELETE等
- 区别：
  · GET用于请求获取资源，POST用于传输数据
  · GET请求参数直接放在URL的后面，而POST请求参数放在请求体中。（实际使用时一些敏感请求（登录、验证）需要使用POST请求）
- 上限：
  有限制的是浏览器中的url长度，不是Http协议，移动端请求无影响。Http服务器部分有限制的设置一下即可。

6、HTTP状态码
- 服务器返回的  **响应报文**  中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。
| 状态码 | 类别 | 原因短语 |
| :---: | :---: | :---: |
| 1XX | Informational（信息性状态码）     | 接收的请求正在处理         |
| 2XX | Success      （成功状态码）       | 请求正常处理完毕          |
| 3XX | Redirection  （重定向状态码）     | 需要进行附加操作以完成请求  |
| 4XX | Client Error （客户端错误状态码）  | 服务器无法处理请求        |
| 5XX | Server Error （服务器错误状态码）  | 服务器处理请求出错        |

7、短连接与长连接？什么是Keep-Alive模式？
- 短连接：建立一个TCP连接，进行一次HTTP请求
- 长连接：建立一个TCP连接，进行多次HTTP请求
- Keep-Alive:又称持久连接、连接重用，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，
  Keep-Alive功能避免了建立或者重新建立连接。

8、TCP的三次握手？四次挥手？
- 三次握手：
  · 第一次握手 客户端发出请求建立连接
  · 第二次握手 服务端回复建立连接的请求
  · 第三次握手 客户端发送自己生成的随机数和收到服务端的随机数
- 为什么要三次握手？
  前两次握手是建立一个连接所必须的，第三次握手是为了避免无效的请求又传到服务器进而产生错误的情况。
- 四次挥手？
  · 第一次 客户端发送FIN请求断开连接
  · 第二次 服务端回复ACK确认信息
  · 第三次 服务端回复FIN断开连接
  · 第四次 客户端发送ACK确认信息
- 为啥要四次挥手？
  · 服务端回复ACK和FIN不是同步的，当客户端发送断开连接请求时，服务端可能还有数据没有发送完毕，当数据发送完毕后
  才会发送FIN报文，最后客户端发送ACK确认关闭连接。

9、TCP的特点？UDP的特点？TCP和UDP区别？  UDP（User Datagram Protocol）
- TCP特点： TCP是一种面向连接的、可靠的、基于字节流运输的通信协议
  · 必须建立连接，形成传输数据的通道
  · 在连接中可以进行大量数据的传递
  · 经历三次握手时可靠协议
  · 必须建立连接效率低
- UDP特点：UDP是一种面向无连接
  · 面向无连接
  · 每个数据报文大小限制在64k以内
  · 不可靠协议                            
  · 速度快、效率高
- Http请求是TCP，DatagramSocket是UDP
- 面向连接？面向无连接？
  区别：
  （1）面向连接，分为三个阶段，建立连接-》传输数据-》释放连接。  数据保序性，大量数据，可靠协议，速度慢，效率低
  （2）面向无连接，直接开始传输数据                         无法保证数据顺序，每次发送的数据有大小限制，不可靠，速度快，效率高
     
10、Cookie、Session、Token之间的区别？作用是啥？
- Cookie :是存储在浏览器目录中的文本文件，存储一些少量的用户信息。
- Session:是客户端和服务端建立连接时添加的标志，最后会转化成一个Cookie发送给客户端。对HTTP请求进行持久化的存储，使得多次请求有相同的标识。
- Token  :是用户身份验证方式，也可以称为令牌。主要用于用户的身份验证。
      
11、网络模型
- 网络模型一般是指OSI（Open System Interconnection开放系统互连）七层参考模型
  | OSI中的层        | 功能                               | TCP/IP协议族                                   |
  | --------        | --------                          |  --------                                     |
  | 7 应用层      	| 文件传输，电子邮件，文件服务，虚拟终端	| TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等	|
  | 6 表示层      	| 数据格式化，代码转换，数据加密      	| 没有协议										|
  | 5 会话层 		| 解除或建立与别的接点的联系      		| 没有协议										|
  | 4 传输层 		| 提供端对端的接口      				| TCP，UDP										|
  | 3 网络层 		| 为数据包选择路由      				| IP，ICMP，OSPF，EIGRP，IGMP					|
  | 2 数据链路层 	    | 传输有地址的帧以及错误检测功能      	| SLIP，CSLIP，PPP，MTU							|
  | 1 物理层 		| 以二进制数据形式在物理媒体上传输数据  	| ISO2110，IEEE802，IEEE802.2					|
  (1)、应用层：如Http协议，它实际定义了如何包装和解析数据，应用层采用HTTP协议后，会按照协议包装数据，如按照请求行、请求头、请求体包装。
  包装好后将数据传输至运输层。
  (2)、运输层：这一层指定了将数据以何种方式传送到端口号。涉及到如何建立连接？如何保证数据不丢失？如何调节流量控制和拥塞控制？等。
  (3)、网络层：这一层指定了将数据传送到那个IP地址。涉及到最优路线，路由选择算法等。
  (4)、数据链路层：如ARP协议，负责把IP地址解析成对应的MAC地址，即硬件地址，这样就能找到对应的唯一机器。
  (5)、物理层：提供二进制传输服务，也就是真正开始通过传输介质（有线、无线）开始进行数据的传输了。
 